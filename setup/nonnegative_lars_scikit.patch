diff --git a/scikit-learn/sklearn/linear_model/least_angle.py b/sklearn/linear_model/least_angle.py
index 5bbf239..5dc04b3 100644
--- a/scikit-learn/sklearn/linear_model/least_angle.py
+++ b/scikit-learn/sklearn/linear_model/least_angle.py
@@ -21,8 +21,8 @@ from ..externals.joblib import Parallel, delayed
 
 
 def lars_path(X, y, Xy=None, Gram=None, max_iter=500,
-              alpha_min=0, method='lar', copy_X=True,
-              eps=np.finfo(np.float).eps,
+              alpha_min=0, method='lar', non_negative=False,
+              copy_X=True, eps=np.finfo(np.float).eps,
               copy_Gram=True, verbose=False):
     """Compute Least Angle Regression and Lasso path
 
@@ -54,6 +54,9 @@ def lars_path(X, y, Xy=None, Gram=None, max_iter=500,
         Specifies the returned model. Select 'lar' for Least Angle
         Regression, 'lasso' for the Lasso.
 
+    non_negative: Boolean, optional
+        If True only return the positive path.
+    
     eps: float, optional
         The machine-precision regularization in the computation of the
         Cholesky diagonal factors. Increase this for very ill-conditioned
@@ -127,9 +130,14 @@ def lars_path(X, y, Xy=None, Gram=None, max_iter=500,
 
     while True:
         if Cov.size:
-            C_idx = np.argmax(np.abs(Cov))
-            C_ = Cov[C_idx]
-            C = np.fabs(C_)
+            if non_negative:
+                C_idx = np.argmax(Cov)
+                C_ = Cov[C_idx]
+                C = C_
+            else:
+                C_idx = np.argmax(np.abs(Cov))
+                C_ = Cov[C_idx]
+                C = np.fabs(C_)
         else:
             C = 0.
 
@@ -161,6 +169,8 @@ def lars_path(X, y, Xy=None, Gram=None, max_iter=500,
             ##########################################################
 
             sign_active[n_active] = np.sign(C_)
+            if non_negative:
+                assert sign_active[n_active] >= 0
             m, n = n_active, C_idx + n_active
 
             Cov[C_idx], Cov[0] = swap(Cov[C_idx], Cov[0])
@@ -215,8 +225,12 @@ def lars_path(X, y, Xy=None, Gram=None, max_iter=500,
             corr_eq_dir = np.dot(Gram[:n_active, n_active:].T,
                                  least_squares)
 
+        # For non_negative case do not use g2 in concordence with paper section 3.4 equation 3.19
         g1 = arrayfuncs.min_pos((C - Cov) / (AA - corr_eq_dir))
-        g2 = arrayfuncs.min_pos((C + Cov) / (AA + corr_eq_dir))
+        if non_negative:
+            g2 = g1
+        else:
+            g2 = arrayfuncs.min_pos((C + Cov) / (AA + corr_eq_dir))
         gamma_ = min(g1, g2, C / AA)
 
         # TODO: better names for these variables: z
